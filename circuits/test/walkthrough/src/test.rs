use k256::elliptic_curve::ff::derive::bitvec::order;
use sp1_sdk::{ProverClient, SP1Stdin, SP1ProvingKey, SP1VerifyingKey, SP1PublicValues};
use sha2::{Digest, Sha256};

#[derive(Clone)]
pub struct Order {
    pub address: [u8; 20],
    pub timestamp: u64,
    pub inflow: Option<u64>,
    pub min_deposit: u64
}

#[derive(Clone)]
pub struct Block {
    pub block_number: u32,
    pub witness_signature: Vec<u8>,
    pub timestamp: u64,
    pub raw_data: Vec<u8>,
    pub transactions: Vec<Vec<u8>>
}

pub struct SP1Data {
    pub client: ProverClient,
    pub stdin: SP1Stdin,
    pub pk: SP1ProvingKey,
    pub vk: SP1VerifyingKey
}

pub struct InputTestData {
    pub previous_block: Block,
    pub blocks: Vec<Block>,
    pub old_orders: Vec<Order>,
    pub new_orders: Vec<Order>,
    pub fee_per_block: u64
}

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
// TODO: This ELF should be generated in ../../../zktron/elf instead
pub const PROGRAM_ELF: &[u8] =
    include_bytes!("../../../elf/riscv32im-succinct-zkvm-elf");

// TODO: Use directly from zktron::lib
pub fn hash(data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(data);

    let mut result = [0u8; 32];
    result.copy_from_slice(&hasher.finalize());
    result
}

pub fn test(input: InputTestData, prove: bool, expect_failure: bool) -> Result<(), String> {
    // Setup the prover client.
    let client = ProverClient::new();
    let (pk, vk) = client.setup(PROGRAM_ELF);

    // Setup the inputs.
    let mut stdin = SP1Stdin::new();

    let InputTestData { previous_block, blocks, old_orders, new_orders, fee_per_block } = input;

    // TODO: Use directly from zktron/lib
    let start_block_number = previous_block.block_number as u64;
    let mut start_block = hash(&previous_block.raw_data); 
    start_block[..8].copy_from_slice(&start_block_number.to_be_bytes());


    let state_length = old_orders.len();
    stdin.write(&(state_length as u32));

    for order in old_orders {
        stdin.write(&order.address);
        stdin.write(&order.timestamp);
        stdin.write(&order.inflow.unwrap_or(0));
        stdin.write(&order.min_deposit);
        println!("order.address: {:?}", order.address);
        println!("order.timestamp: {:?}", order.timestamp);
        println!("order.inflow.unwrap_or(0): {:?}", order.inflow.unwrap_or(0));
        println!("order.min_deposit: {:?}", order.min_deposit);
    }

    stdin.write(&[0u8; 20]); // Empty address (relayer address)
    stdin.write(&[0u8; 32]); // TODO: Add start order chain hash from input data

    let order_length = new_orders.len();
    stdin.write(&(order_length as u32));

    for order in new_orders {
        stdin.write(&order.timestamp);
        stdin.write(&order.address);
        stdin.write(&order.min_deposit);
        println!("order.timestamp: {:?}", order.timestamp);
        println!("order.address: {:?}", order.address);
        println!("order.min_deposit: {:?}", order.min_deposit);
    }

    let block_count = blocks.len();
    stdin.write(&start_block); // start_block
    stdin.write(&(block_count as u32)); // block_count
    stdin.write(&fee_per_block); // fee_per_block

    for block in blocks {
        let raw_data = block.raw_data;
        println!("block.raw_data: {:?}", raw_data.clone());
        stdin.write_vec(raw_data); // raw_data

        let tx_count = block.transactions.len();
        println!("tx_count as u32: {:?}", tx_count as u32);

        stdin.write(&(tx_count as u32));
        for transaction in block.transactions {
            println!("transaction: {:?}", transaction);
            stdin.write_vec(transaction); // transactions
        }
    }

    // TODO: Some stdin::read is failing when executing the circuit, find out why!
    println!("state_length: {:?}", state_length);
    println!("order_length: {:?}", order_length as u32);
    println!("start_block: {:?}", start_block);
    println!("block_count as u32: {:?}", block_count as u32);
    println!("fee_per_block: {:?}", fee_per_block);

    if prove {
        // Generate the proof.
        let proof = client.prove_compressed(&pk, stdin).expect("failed to generate proof");
        println!("Successfully executed proof!\n");

        println!("Public values: {:?}", proof.public_values);

        // Verify the proof
        let verified = client
            .verify_compressed(&proof, &vk)
            .expect("failed to verify proof");

        println!("Successfully verified proof!\n");
        println!("Verified: {:?}", verified);
        // TODO: Validate that public values are ok
        Ok(())
    } else {
        let result = client.execute(PROGRAM_ELF, stdin.clone());

        match result {
            Ok((public_values, execution_report)) => {
                if expect_failure {
                    println!("Test did not pass as expected failure was set.");
                    Err("Test did not pass as expected failure was set.".to_string())
                } else {
                    println!("Successfully executed proof!\n");
                    println!("Public values: {:?}", public_values);
                    println!("Execution report: {:?}", execution_report);
                    Ok(())
                }
            },
            Err(e) => {
                if expect_failure {
                    println!("Successfully failed execution as expected failure was set.");
                    Ok(())
                } else {
                    println!("Failed execution unexpectedly: {:?}", e);
                    Err(format!("Failed execution unexpectedly: {:?}", e))
                }
            },
        }
    }
}