// This is a script to test the circuit against real Tron data
// and calculate the proving complexity

use sp1_core::runtime::SyscallCode;
use sp1_sdk::{ProverClient, SP1Stdin};
use serde::Deserialize;
use sha2::{Sha256, Digest};
use k256::ecdsa::{RecoveryId, Signature, VerifyingKey};
use tonic::transport::Channel;
use tonic::Request;
use block_header::Raw;

tonic::include_proto!("protocol");

use wallet_client::WalletClient;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const PROGRAM_ELF: &[u8] =
    include_bytes!("../../../zktron/elf/riscv32im-succinct-zkvm-elf");

async fn get_block_by_number(
    client: &mut WalletClient<Channel>,
    block_number: u32,
) -> Result<(Vec<u8>, Raw), Box<dyn std::error::Error>> {
    let request = Request::new(NumberMessage {
        num: block_number as i64,
    });

    let response = client.get_block_by_num2(request).await?;
    let block = response.into_inner();

    Ok((
        block.block_header.unwrap().witness_signature,
        block.block_header.unwrap().raw_data.unwrap()
    ))
}

fn sample_block_range(
    start_block: u32,
    end_block: u32,
    sample_size: u32,
    random_seed: u8,
) -> Option<(u32, u32)> {
    let total_blocks = end_block - start_block + 1;

    // Ensure there are enough blocks to sample
    if total_blocks < sample_size {
        return None;
    }

    // Seed the random number generator
    let mut rng = StdRng::seed_from_u64(random_seed.into());

    // Determine the starting point within the range
    let max_start = total_blocks - sample_size;
    let random_start = rng.gen_range(0..=max_start);

    // Calculate the start and end of the sampled range
    let sampled_start_block = start_block + random_start;
    let sampled_end_block = sampled_start_block + sample_size - 1u32;

    Some((sampled_start_block, sampled_end_block))
}


#[derive(Deserialize)]
struct Data {
    list: Vec<String>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the inputs.
    let mut stdin = SP1Stdin::new();

    let channel = Channel::from_shared("http://grpc.trongrid.io:50051")?
        .connect()
        .await?;
    let mut wallet_client = WalletClient::new(channel);

    // Sample 200 sequential blocks between block number 64301464 and 64308662 (epoch)
    let init_epoch_block = 64301464;
    let end_epoch_block = 64308662;
    let sample_size = 200;
    let random_seed = 0xaeu8;

    // Call the function and destructure the result to get the start and end blocks
    let Some((sampled_start, sampled_end)) = sample_block_range(start_block, end_block, sample_size, random_seed);

    let start_block = sampled_start;
    let end_block = sampled_end;
    

    // Create different tests to prove the circuit with different witnesses.

    // 1. Test with 19 blocks, where:
    //      - All blocks are valid
    //      - All blocks are chained
    //      - All blocks are signed by a valid SR
    //      - All blocks follow a round robin pattern on the SR signing
    //      - Prove that y = f(x,w) is the same as y = C(x,w)



    
    
    let block_count = 19u32;

    stdin.write(&start_block.to_le_bytes()); // start_block
    stdin.write(&block_count.to_le_bytes()); // block_count
    for block_number in start_block..end_block {
        let (witness_signature, public_key, raw_data) = get_block_by_number(&mut wallet_client, block_number).await?;
        println!("Block number: {}", block_number);
        println!("Witness signature: {:?}", witness_signature);
        println!("Public key: {:?}", public_key);
        println!("Raw data: {:?}", raw_data);

        stdin.write(&public_key); // srs_list
        stdin.write(&raw_data); // raw_data
        stdin.write(&witness_signature); // signature
    }

    println!("generating...");

    // Generate the proof.
    let (public_values, execution_report) = client
        .execute(PROGRAM_ELF, stdin)
        .expect("failed to generate proof");
    println!("Successfully executed proof!\n");

    println!("Public values: {:?}", public_values);
    println!("Execution report: {:?}\n", execution_report);

    let tic = execution_report.total_instruction_count();
    let tsc = *execution_report
        .syscall_counts
        .get(&SyscallCode::SHA_COMPRESS)
        .unwrap();

    Ok(())
}