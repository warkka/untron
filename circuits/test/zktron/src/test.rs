use k256::elliptic_curve::rand_core::block;
use sp1_sdk::{ProverClient, SP1Stdin, SP1ProvingKey, SP1VerifyingKey, SP1PublicValues};
use sha2::{Digest, Sha256};

#[derive(Clone)]
pub struct Block {
    pub block_number: u32,
    pub witness_signature: Vec<u8>,
    pub raw_data: Vec<u8>,
}

pub struct SP1Data {
    pub client: ProverClient,
    pub stdin: SP1Stdin,
    pub pk: SP1ProvingKey,
    pub vk: SP1VerifyingKey,
}

pub struct InputTestData {
    pub previous_block: Block,
    pub blocks: Vec<Block>,
    pub srs_list: Vec<Vec<u8>>,
}

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
// TODO: This ELF should be generated in ../../../zktron/elf instead
pub const PROGRAM_ELF: &[u8] =
    include_bytes!("../../../elf/riscv32im-succinct-zkvm-elf");

    // TODO: Use directly from zktron::lib
pub fn hash(data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(data);

    let mut result = [0u8; 32];
    result.copy_from_slice(&hasher.finalize());
    result
}

pub fn test(input: InputTestData, prove: bool, expect_failure: bool) -> Result<(), String> {
    // Setup the prover client.
    let client = ProverClient::new();
    let (pk, vk) = client.setup(PROGRAM_ELF);

    // Setup the inputs.
    let mut stdin = SP1Stdin::new();

    let InputTestData { previous_block, blocks, srs_list } = input;

    // TODO: Use directly from zktron/lib
    let start_block_number = previous_block.block_number as u64;
    let mut start_block = hash(&previous_block.raw_data); 
    start_block[..8].copy_from_slice(&start_block_number.to_be_bytes());

    let block_count = blocks.len() as u32;

    stdin.write(&start_block); // start_block
    stdin.write(&block_count); // block_count

    for sr in srs_list {
        stdin.write_vec(sr); // srs_list
    }

    for block in blocks {
        stdin.write_vec(block.raw_data); // raw_data
        stdin.write_vec(block.witness_signature); // signature
    }

    if prove {
        // Generate the proof.
        let proof = client.prove_compressed(&pk, stdin).expect("failed to generate proof");
        println!("Successfully executed proof!\n");

        println!("Public values: {:?}", proof.public_values);

        // Verify the proof
        let verified = client
            .verify_compressed(&proof, &vk)
            .expect("failed to verify proof");

        println!("Successfully verified proof!\n");
        println!("Verified: {:?}", verified);
        // TODO: Validate that public values are ok
        Ok(())
    } else {
        let result = client.execute(PROGRAM_ELF, stdin.clone());

        match result {
            Ok((public_values, execution_report)) => {
                if expect_failure {
                    println!("Test did not pass as expected failure was set.");
                    Err("Test did not pass as expected failure was set.".to_string())
                } else {
                    println!("Successfully executed proof!\n");
                    println!("Public values: {:?}", public_values);
                    println!("Execution report: {:?}", execution_report);
                    Ok(())
                }
            },
            Err(e) => {
                if expect_failure {
                    println!("Successfully failed execution as expected failure was set.");
                    Ok(())
                } else {
                    println!("Failed execution unexpectedly: {:?}", e);
                    Err(format!("Failed execution unexpectedly: {:?}", e))
                }
            },
        }
    }
}